package com.doc.impl;

import com.doc.dto.productMilestoneMap.ProductMilestoneMapRequestDto;
import com.doc.dto.productMilestoneMap.ProductMilestoneMapResponseDto;
import com.doc.entity.product.Milestone;
import com.doc.entity.product.Product;
import com.doc.entity.product.ProductMilestoneMap;

import com.doc.repository.MilestoneRepository;
import com.doc.repository.ProductMilestoneMapRepository;
import com.doc.repository.ProductRepository;
import com.doc.service.ProductMilestoneMapService;
import jakarta.persistence.EntityNotFoundException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.Date;

/**
 * Service implementation for managing ProductMilestoneMap entities.
 */
@Service
@Transactional
public class ProductMilestoneMapServiceImpl implements ProductMilestoneMapService {

    private static final Logger logger = LoggerFactory.getLogger(ProductMilestoneMapServiceImpl.class);

    @Autowired
    private ProductMilestoneMapRepository productMilestoneMapRepository;



    @Autowired
    private ProductRepository productRepository;

    @Autowired
    private MilestoneRepository milestoneRepository;

    @Override
    public ProductMilestoneMapResponseDto createProductMilestoneMap(ProductMilestoneMapRequestDto requestDto) {
        logger.info("Creating product-milestone mapping for product ID: {} and milestone ID: {}",
                requestDto.getProductId(), requestDto.getMilestoneId());

        // Validate product and milestone existence
        Product product = productRepository.findByIdAndIsDeletedFalse(requestDto.getProductId())
                .orElseThrow(() -> new EntityNotFoundException("Product not found with ID: " + requestDto.getProductId()));
        Milestone milestone = milestoneRepository.findById(requestDto.getMilestoneId())
                .orElseThrow(() -> new EntityNotFoundException("Milestone not found with ID: " + requestDto.getMilestoneId()));

        // Check for duplicate order for the product
        if (productMilestoneMapRepository.existsByProductIdAndOrder(requestDto.getProductId(), requestDto.getOrder())) {
            throw new IllegalArgumentException("Order " + requestDto.getOrder() + " already exists for product ID: " + requestDto.getProductId());
        }

        ProductMilestoneMap mapping = new ProductMilestoneMap();
        mapping.setProduct(product);
        mapping.setMilestone(milestone);
        mapping.setOrder(requestDto.getOrder());
        mapping.setTatInDays(requestDto.getTatInDays());
        mapping.setRollbackTatInDays(requestDto.getRollbackTatInDays());
        mapping.setStrictApproval(requestDto.isStrictApproval());
        mapping.setAllowRollback(requestDto.isAllowRollback());
        mapping.setMaxAttempts(requestDto.getMaxAttempts());
        mapping.setMandatory(requestDto.isMandatory());
        mapping.setPaymentPercentage(requestDto.getPaymentPercentage());
        mapping.setAutoGenerated(requestDto.isAutoGenerated());
        mapping.setCreatedDate(new Date());
        mapping.setUpdatedDate(new Date());
        mapping.setDate(LocalDate.now());

        ProductMilestoneMap savedMapping = productMilestoneMapRepository.save(mapping);
        logger.info("Product-milestone mapping created with ID: {}", savedMapping.getId());
        return mapToResponseDto(savedMapping);
    }

    @Override
    public ProductMilestoneMapResponseDto updateProductMilestoneMap(Long id, ProductMilestoneMapRequestDto requestDto) {
        logger.info("Updating product-milestone mapping with ID: {}", id);

        ProductMilestoneMap existingMapping = productMilestoneMapRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Product-milestone mapping not found with ID: " + id));

        // Validate product and milestone existence
        Product product = productRepository.findByIdAndIsDeletedFalse(requestDto.getProductId())
                .orElseThrow(() -> new EntityNotFoundException("Product not found with ID: " + requestDto.getProductId()));
        Milestone milestone = milestoneRepository.findById(requestDto.getMilestoneId())
                .orElseThrow(() -> new EntityNotFoundException("Milestone not found with ID: " + requestDto.getMilestoneId()));

        // Check for duplicate order for the product (excluding this mapping)
        if (existingMapping.getOrder() != requestDto.getOrder() &&
                productMilestoneMapRepository.existsByProductIdAndOrder(requestDto.getProductId(), requestDto.getOrder())) {
            throw new IllegalArgumentException("Order " + requestDto.getOrder() + " already exists for product ID: " + requestDto.getProductId());
        }

        existingMapping.setProduct(product);
        existingMapping.setMilestone(milestone);
        existingMapping.setOrder(requestDto.getOrder());
        existingMapping.setTatInDays(requestDto.getTatInDays());
        existingMapping.setRollbackTatInDays(requestDto.getRollbackTatInDays());
        existingMapping.setStrictApproval(requestDto.isStrictApproval());
        existingMapping.setAllowRollback(requestDto.isAllowRollback());
        existingMapping.setMaxAttempts(requestDto.getMaxAttempts());
        existingMapping.setMandatory(requestDto.isMandatory());
        existingMapping.setPaymentPercentage(requestDto.getPaymentPercentage());
        existingMapping.setAutoGenerated(requestDto.isAutoGenerated());
        existingMapping.setUpdatedDate(new Date());


        ProductMilestoneMap updatedMapping = productMilestoneMapRepository.save(existingMapping);
        logger.info("Product-milestone mapping updated with ID: {}", updatedMapping.getId());
        return mapToResponseDto(updatedMapping);
    }

    @Override
    public ProductMilestoneMapResponseDto getProductMilestoneMapById(Long id) {
        logger.info("Fetching product-milestone mapping with ID: {}", id);
        ProductMilestoneMap mapping = productMilestoneMapRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Product-milestone mapping not found with ID: " + id));
        return mapToResponseDto(mapping);
    }

    @Override
    public Page<ProductMilestoneMapResponseDto> getAllProductMilestoneMaps(Pageable pageable) {
        logger.info("Fetching all product-milestone mappings with pageable: {}", pageable);
        return productMilestoneMapRepository.findAll(pageable)
                .map(this::mapToResponseDto);
    }

    @Override
    public void deleteProductMilestoneMap(Long id) {
        logger.info("Deleting product-milestone mapping with ID: {}", id);
        ProductMilestoneMap mapping = productMilestoneMapRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Product-milestone mapping not found with ID: " + id));
        productMilestoneMapRepository.delete(mapping);
        logger.info("Product-milestone mapping deleted with ID: {}", id);
    }

    @Override
    public Page<ProductMilestoneMapResponseDto> getProductMilestoneMapsByProduct(Long productId, Pageable pageable) {
        logger.info("Fetching product-milestone mappings for product ID: {} with pageable: {}", productId, pageable);
        if (!productRepository.findByIdAndIsDeletedFalse(productId).isPresent()) {
            throw new EntityNotFoundException("Product not found with ID: " + productId);
        }
        return productMilestoneMapRepository.findByProductId(productId, pageable)
                .map(this::mapToResponseDto);
    }

    private ProductMilestoneMapResponseDto mapToResponseDto(ProductMilestoneMap mapping) {
        ProductMilestoneMapResponseDto dto = new ProductMilestoneMapResponseDto();
        dto.setId(mapping.getId());
        dto.setProductId(mapping.getProduct().getId());
        dto.setMilestoneId(mapping.getMilestone().getId());
        dto.setMilestoneName(mapping.getMilestone().getName());
        dto.setOrder(mapping.getOrder());
        dto.setTatInDays(mapping.getTatInDays());
        dto.setRollbackTatInDays(mapping.getRollbackTatInDays());
        dto.setStrictApproval(mapping.isStrictApproval());
        dto.setAllowRollback(mapping.isAllowRollback());
        dto.setMaxAttempts(mapping.getMaxAttempts());
        dto.setMandatory(mapping.isMandatory());
        dto.setPaymentPercentage(mapping.getPaymentPercentage());
        dto.setAutoGenerated(mapping.isAutoGenerated());
        return dto;
    }
}